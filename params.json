{
  "name": "C4",
  "tagline": "do not use the add or sub and finish two numbers add",
  "body": "求两个数的和，不允许使用加法和减法\r\n====\r\n\r\n\r\n当看到这个题目的时候，大概就有两种方法来实现；   \r\n一种是只要是和算术相关的操作都可以使用位操作来进行变相实现。   \r\n  最先想到的就是位操作来解决，如下：     \r\n  \r\n\r\n``` c\r\nint add1(int x, int y) \r\n{\r\n    if (y == 0) {\r\n        return x;\r\n    }\r\n\r\n    return add1(x ^ y, (x & y) << 1);\r\n\r\n}\r\n```\r\n\r\n   把加法拆成两部分来操作，一部分是做简单的加法，另一部分是做进位操作；\r\n其中x^y是简单的加，无进位。x&y是求进位，(x & y) << 1表示进位的数左移一\r\n位和之前无进位的数做求和；    \r\n\r\n   \r\n\r\n\r\n另一种是利用某种机制来做间接的调用加减法,利用a[i] 等价于*(a+i)机制：\r\n\r\n```c\r\nlong add2(int x, int y)\r\n{\r\n    return (long)(&((char*)x)[y]);\r\n}\r\n\r\n\r\n```\r\n\r\n   首先我们知道，a[i]是和*(a+i)是等价的然而加i会偏移多少，这个取决于a的类型，如果a\r\n是char型的则加1就是加1字节；这个地方就利用这个机制，(char*)x把整数x强转为char类型的\r\n指针想当与数组名首地址a，然后((char*)x)[y]这个就等价于*（x+y）取对应空间里面的值，\r\n这个时候我们并不想要这个地址里存储的值，而是想要这个值对应的地址，所以&((char*)x)[y]\r\n进行和*符合抵消，最后把这个地址转换为long类型；\r\n  注意：指针在64位操作系统里面是8字节。\r\n\r\n\r\n\r\n\r\n\r\n\r\n欢迎一起交流学习 \r\n====\r\n \r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/u/2786211992/home)\r\n\r\n\r\nThx\r\n====\r\n\r\n* chunshengsterATgmail.com\r\n\r\n\r\nAuthor\r\n====\r\n* Linux\\nginx\\golang\\c\\c++爱好者\r\n* 欢迎一起交流  一起学习# \r\n* Others say good and Others good\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}